# -*- coding: utf-8 -*-
import logging
import collections
import math
import os
import json
from . import fileurl

mylogger = logging.getLogger(__name__)
sh = logging.StreamHandler()
mylogger.addHandler(sh)
mylogger.setLevel(logging.DEBUG)

def load_config(config_file):
	with open(config_file) as conf:
		data = json.load(conf)
	return data

def path_to_file(filename, folder):
    _ROOT = os.path.abspath(os.path.dirname(__file__))
    return os.path.join(_ROOT, folder, filename)

def get_count_suspicious_sections(pe):
    '''
    악성코드에서 자주 출현하는 섹션의 유/무
    '''

    try:
        malicious_sections = collections.OrderedDict({
            '.text': 0,
            '.data': 0,
            '.rdata': 0,
            '.idata': 0,
            '.rsrc': 0,
            '.bss': 0,
            '.crt': 0,
            '.tls': 0
        })

        for section in pe.sections:
            section_name = section.Name.decode('utf-8')
            section_name = section_name.split('\00')[0].lower()

            # 섹션 이름이 있으면 딕셔너리 값을 1로 수정
            if section_name in malicious_sections:
                malicious_sections[section_name] = 1

        return malicious_sections

    except Exception as e:
        mylogger.debug('get_count_suspicious_section is failed')
        return None

def get_entropy(binarydata):
    '''
    파일의 엔트로피를 구하는 함수
    엔트로피 알고리즘: Shannon entropy
    소스코드: https://github.com/erocarrera/pefile/blob/master/pefile.py의 entropy_H 함수
    '''
    if not binarydata:
        return 0.0

    occurences = collections.Counter(bytearray(binarydata))
    entropy = 0.0

    for x in occurences.values():
        p_x = float(x) / len(binarydata)
        entropy -= p_x * math.log(p_x, 2)

    return entropy

def extract_strings(filepath):
    strings = fileurl.get_result(filepath, load_config(path_to_file('stringsmatch.json', 'signatures')))

    return strings